# AI 챗봇 서비스 

### 📄 작업 내용

AI 챗봇 서비스 백엔드 과제의 전체 요구사항을 구현했습니다. 사용자 인증부터 대화 관리, 피드백, 관리자용 분석/보고 API까지 모든 기능을 개발했습니다.

1.  **아키텍처 설계 및 개발 환경 구축**
    * **계층형 아키텍처 도입**: `api`, `application`, `domain`, `global` 등 각 계층의 역할을 명확히 분리하여 확장성과 유지보수성을 고려한 구조를 설계했습니다.
    * **PostgreSQL 도입 및 DataGrip 연동**: 초기 개발 단계에서 H2 인메모리 DB의 데이터 관찰 한계로 인해 발생한 문제를 해결하고자, 영속적 데이터베이스인 **PostgreSQL**로 전환했습니다. **DataGrip**을 연동하여 데이터의 상태를 직접 확인하며 디버깅 하였습니다.
    * **테스트 환경 분리**: `src/test/resources`에 별도의 `application.yml`을 구성하여, 테스트 시에는 H2 인메모리 DB(`ddl-auto: create-drop`)가 동작하도록 설정했습니다. 

2.  **사용자 인증/인가 기능 구현**
    * **JWT 기반 인증**: Spring Security를 사용하여 상태 없는(Stateless) 인증 시스템을 구축했으며, `JwtTokenProvider`와 `JwtAuthenticationFilter`를 통해 토큰 기반 인증 플로우를 구현했습니다.
    * **역할 기반 인가**: `@EnableMethodSecurity`를 활성화하고, `@PreAuthorize("hasRole('ADMIN')")` 어노테이션을 사용하여 관리자 전용 API에 대한 접근 제어를 구현했습니다.

3.  **핵심 기능 구현 (대화 및 피드백)**
    * **대화 관리**: "30분 경과 시 새 스레드 생성" 규칙을 `ChatService`에 구현했으며, Java 표준 라이브러리와의 이름 충돌을 피하고자 `Thread` Entity를 `ChatThread`로 리네이밍하여 코드의 명확성을 확보했습니다.
    * **피드백 관리**: 사용자가 자신의 대화에만 피드백을 남길 수 있도록 소유권을 검증하고, 동일한 대화에 중복 피드백을 남길 수 없도록 방지하는 로직을 구현했습니다.

### 💬 리뷰 중점 사항

구현을 진행하면서 아래 두 가지 포인트에 대해 특히 많이 고민했습니다. 리뷰 시 이 부분들을 중점적으로 봐주시면 감사하겠습니다.

1.  **DB 환경 전략: `H2` vs `PostgreSQL`**
    * **고민**: 초기에는 빠른 개발 속도를 위해 H2 인메모리 DB로 시작했습니다. 하지만 `createdAt` 타임스탬프 형식 오류, ADMIN 역할 데이터 검증 등 미묘한 버그가 발생했을 때, 데이터의 실제 상태를 직접 확인할 수 없어 원인 파악에 오랜 시간이 걸렸습니다.
    * **리뷰 요청**: 이 경험을 통해 개발 초기 단계이더라도 데이터 관찰과 디버깅 효율을 위해 **PostgreSQL + DataGrip** 환경을 구축하는 방향으로 전환했습니다. 이 결정이 3시간이라는 제한된 시간 내에 구현함에있어 안정성을 높이는 데 더 적절한 트레이드오프였는지, 혹은 다른 더 나은 접근 방식이 있었을지에 대한 의견을 여쭙고 싶습니다.

2.  **인가(Authorization) 문제 해결 방식**
    * **고민**: 관리자 계정의 데이터와 토큰이 모두 정상임에도 불구하고, 관리자 API에서 계속 `403 Forbidden` 에러가 발생하는 문제를 마주했습니다.
    * **리뷰 요청**: 이 문제를 해결하기 위해, 코드나 데이터를 계속 수정해보는 대신 **Spring Security의 DEBUG 로그를 활성화**하여 프레임워크의 내부 동작을 추적했습니다. 로그 분석을 통해 `hasRole` 검증 시 `ROLE_` 접두사가 필요하다는 규칙을 발견하고, `JwtTokenProvider`에서 이를 적용하여 근본적인 원인을 해결했습니다. 이처럼 프레임워크 내부 동작을 깊이 파고들어 해결하는 접근 방식이 실무적인 문제 해결에 적합한지에 대한 리뷰를 부탁드립니다.

#### 1. 과제를 어떻게 분석하셨나요?

3시간이라는 시간제한을 고려하여 **MVP(Minimum Viable Product) 접근법**을 채택했습니다. 먼저 사용자 인증처럼 다른 모든 기능의 기반이 되는 기능을 최우선으로 구현했습니다. 이후 대화, 피드백, 관리자 기능 순으로 핵심 요구사항을 구현하고, 각 기능 구현 시 단순히 요구사항을 만족시키는 것을 넘어, **확장성과 실무적인 코드 품질**을 고려했습니다. 예를 들어, 처음부터 계층형 아키텍처를 도입하고, 테스트 환경을 분리하며, 예외 처리를 위한 `GlobalExceptionHandler`를 구현한 것이 그 예입니다.

#### 2. 과제 진행에 있어 AI를 어떻게 활용하셨나요? 어떤 어려움이 있었나요?

-   **Boilerplate 코드 생성**: JPA Entity, DTO, Repository, Service, Controller의 기본 골격을 빠르게 생성하여 반복 작업을 최소화했습니다.
-   **개념 설명 및 추천**: `@AuthenticationPrincipal`, `@PreAuthorize`, `@PageableDefault` 등 Spring의 고급 기능에 대한 정확한 사용법과 원리를 질문하여 코드의 품질을 높였습니다.
-   **디버깅 파트너**: `403 Forbidden`, `createdAt` 형식 오류, `Unresolved Reference` 등 다양한 에러 발생 시, 에러 로그를 공유하고 가능한 원인과 해결책에 대한 아이디어를 얻었습니다. 특히 **`ROLE_` 접두사 문제**처럼 경험이 없으면 찾기 어려운 문제의 해결 방향을 잡는 데 큰 도움을 받았습니다.

**어려움**: AI가 제안한 코드가 현재 프로젝트의 특정 맥락(e.g., `Thread` 이름 충돌, 특정 라이브러리 버전)을 완벽히 이해하지 못하는 경우가 있었습니다. 따라서 제안된 코드를 그대로 사용하기보다, 비판적으로 검토하고 제 상황에 맞게 수정하며 최종적으로 직접 문제를 해결하는 과정이 필수적이었습니다.

#### 3. 지원자가 구현하기 가장 어려웠던 1개 이상의 기능을 설명해주세요.

**관리자 API의 `403 Forbidden` 에러 해결 과정**이 가장 도전적이었습니다. 단순히 코드를 짜는 것이 아닌, 문제의 근본 원인을 찾아가는 체계적인 디버깅 과정 전체가 어려웠기 때문입니다.

1.  **초기 문제**: `ADMIN` 역할의 사용자 토큰으로 관리자 API를 호출했음에도 `403 Forbidden` 에러가 발생했습니다.
2.  **1차 진단 및 해결**: 데이터베이스 문제일 수 있다는 가정 하에, H2에서 **PostgreSQL + DataGrip** 환경으로 전환하여 실제 DB 데이터를 확인했습니다. DB에는 `ROLE`이 'ADMIN'으로 정확히 저장되어 있음을 확인했으나 문제는 계속되었습니다.
3.  **2차 진단 및 해결**: Spring Security의 문제로 범위를 좁히고, `logging.level`을 DEBUG로 설정하여 상세 로그를 분석했습니다. 로그를 통해 Spring Security가 `hasRole('ADMIN')` 규칙을 위해 `ROLE_ADMIN`이라는 권한을 찾고 있음을 발견했습니다.
4.  **최종 해결**: `JwtTokenProvider`에서 토큰의 역할 정보를 바탕으로 `Authentication` 객체를 만들 때, `"ROLE_"` 접두사를 붙여주지 않은 것이 최종 원인임을 파악하고 코드를 수정하여 문제를 해결했습니다.

이 과정은 복잡한 알고리즘은 없었지만, **설정, 데이터, 코드 컨벤션** 등 여러 계층에 걸친 문제를 체계적으로 분석하고, 로그와 실제 데이터를 기반으로 가설을 세우고 검증하는 실무적인 문제 해결 능력을 요구하는 값진 경험이었습니다.
